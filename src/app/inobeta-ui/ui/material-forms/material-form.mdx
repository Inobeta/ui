import { Meta, Canvas, Source } from "@storybook/blocks";

import * as MatFormStories from "./material-form.stories";

<Meta title="Forms/Overview" />

# Forms

## Getting started

First, add `ib-material-form` to your page's template.

Then, add field definitions through the `fields` input.

> **Don't forget to add at least a form action with key `"submit"`**

Lastly, listen to `(ibSubmit)` to, for example, send a request to an endpoint.

```typescript
@Component({
  selector: "app-form-example",
  templateUrl: "form.component.html",
})
export class FormExampleComponent {
  fields = [
    // your fields
  ];

  // An action with a submit key is *always* required
  actions = [
    new IbMatButtonControl({
      key: "submit",
      label: "Login",
    }),
  ];

  handleSubmit(data) {
    // ...
  }
}
```

```html
<!-- form.component.html -->
<ib-material-form
  [fields]="fields"
  [actions]="actions"
  (ibSubmit)="handleSubmit($event)"
/>
```

## Form fields

Form fields are defined through an array of control instances.  
The only required values are `key` and `label`, where `key` is assigned as `formControlName`  
You can find a list of available controls [here](/docs/forms-controls--docs)

```typescript
fields = [
  new IbMatTextboxControl({
    key: "fullName",
    label: "Full name",
  }),
];
```

<Canvas of={MatFormStories.Textbox} />

## Form actions

It is possible to extend the available actions beyond submit through the `actions` input.  
Each action needs a `key`, `label`, and `handler` (callback) field (except for the button related to form submit.)

```typescript
customActions = [
  // üëá this is required!
  new IbMatButtonControl({
    key: "submit",
    label: "Search",
  }),
  new IbMatButtonControl({
    key: "clear",
    label: "Clear",
    color: "accent",
    requireConfirmOnDirty: true,
    handler: (form) => form.reset(),
  }),
  new IbMatButtonControl({
    key: "disable",
    label: "Disable",
    handler: (form) => form.disable(),
  }),
  new IbMatButtonControl({
    key: "enable",
    label: "Enable",
    handler: (form) => form.enable(),
  }),
];
```

## Initialize data

Form data can be initialized, or overwritten at any time, with the `value` input.

> The data passed down through this input is applied calling the `patchValue` method of a `FormGroup`  
> This means that missing control keys will not be reset on their own

```typescript
value = { firstName: "John", lastName: "Doe" };

fields = [
  new IbMatTextboxControl({
    key: "firstName",
    label: "First name",
  }),
  new IbMatTextboxControl({
    key: "lastName",
    label: "Last name",
  }),
];
```

<Canvas of={MatFormStories.PreInitialized} />

## Validation

Every form control has a `validators` key.
It accepts an array of `ValidatorFn`, like either one provided from `Validators` or your own.

```typescript
fields = [
  new IbMatTextboxControl({
    key: "email",
    label: "Email",
    type: "email",
    validators: [Validators.email, Validators.required],
    width: "100%",
  }),
  new IbMatTextboxControl({
    key: "password",
    label: "Password",
    type: "password",
    validators: [Validators.required],
    width: "100%",
  }),
  new IbMatSlideToggleControl({
    key: "storeUserAgent",
    label: "Remember this device",
    width: "100%",
  }),
];
```

<Canvas of={MatFormStories.SimpleLogin} />

## Form array

With `IbFormArray` define a form array where a user can add a variable amount of lines of pre-defined fields.  
Same as a form control, it requires a `key` parameter, which corresponds to the key in the FormGroup;
and the `fields` parameter accepts any control available.

To limit the maximum amount of lines, set the `options.max` parameter to a value greater than zero.

```typescript
fields = [
  // ...
  new IbFormArray({
    key: "addresses",
    options: {
      max: 2,
    },
    fields: [
      new IbMatTextboxControl({
        key: "key",
        label: "(es. Phone, Email)",
        width: "25%",
      }),
      new IbMatTextboxControl({
        key: "value",
        label: "es. +39123123",
        validators: [Validators.required],
        width: "25%",
      }),
    ],
  }),
];
```

<Canvas of={MatFormStories.WithFormArray} />

## Build your own control

The following example extends the common interfaces exposed by the library to create a new text form field with an icon.

First, create your template, assign the the field's `[formGroup]` with the `data.form` property. It contains the `FormGroup` instance
this control is part of.

Next, assign the `[formControlName]` with the `data.base.key` property, this is the same `key` that will be passed down to the control.

```typescript
fields = [
  new IbMatTextboxControl({
    key: "email", // üëà this key
    label: "Email", // while this is available in `data.base.label`
    /**
     * üíÅ Every parameter assigned here is available under `data.base`
     */
  }),
];
```

Listen to the `(keyup)` and `(change)` events, if that's necessary, binding them to the callback available under `data.base.change`

Then, add the template outlet `data.formControlErrors` dedicated to the errors. This will make sure that validation errors can be shown.

```html
<mat-error>
  <ng-container
    *ngTemplateOutlet="data.formControlErrors; context: this"
  ></ng-container>
</mat-error>
```

```html
<!-- textbox-with-icon.component.html -->
<mat-form-field appearance="fill" style="width: 100%;" [formGroup]="data.form">
  <mat-label>{{ data.base.label | translate }}</mat-label>
  <input
    matInput
    [formControlName]="data.base.key"
    [id]="data.base.key"
    (keyup)="data.base.change(data.self)"
    (change)="data.base.change(data.self)"
  />
  <mat-icon matSuffix *ngIf="data.base.iconName"
    >{{ data.base.iconName }}</mat-icon
  >
  <mat-error>
    <ng-container
      *ngTemplateOutlet="data.formControlErrors; context: this"
    ></ng-container>
  </mat-error>
</mat-form-field>
```

Implement the `IbFormControlInterface` interface on your component's class.
Create a new type by extending the type `IbFormControlBaseParams` to include your own parameters.  
In this case, the `iconName`

```typescript
// textbox-with-icon.component.ts
@Component({
  selector: "[ib-custom-textbox-with-icon]",
  templateUrl: "textbox-with-icon.component.html",
})
export class IbTextboxWithIconComponent implements IbFormControlInterface {
  @Input() data: any;
}
```

```typescript
// textbox-with-icon.component.ts
export type TextboxWithIconParams = IbFormControlBaseParams<string> & {
  iconName: string;
};
```

Lastly, write the control class, that will be used within the `fields` array like any other available control.  
Extend `IbFormControlBase`, initialize your parameters and assign the custom control component.

```typescript
// textbox-with-icon.component.ts
export class IbTextboxWithIconControl extends IbFormControlBase<string> {
  iconName: string;
  constructor(options: TextboxWithIconParams) {
    super(options);
    this.iconName = options.iconName;
    this.control = new IbFormControlBaseComponent(IbTextboxWithIconComponent, {
      base: this,
    });
  }
}
```

## Form lifecycle hooks

Accessing to a form with `@ViewChild` will let you access to its lifecycle hooks through the observables `afterInit()` and `afterChanges()`

```html
<!-- form-hooks.component.html -->
<ib-material-form
  #form
  [fields]="fields"
  [actions]="actions"
  (ibSubmit)="handleSubmit($event)"
/>
```

```typescript
@Component({
  selector: "app-form-hooks-example",
  template: `form-hooks.component.html`,
})
export class FormHooksExampleComponent {
  @ViewChild("form", { static: true })
  form: IbMaterialFormComponent;

  fields = [
    // your fields
  ];

  actions = [
    // your actions
  ];

  ngOnInit() {
    this.form.afterInit().subscribe((form) => {
      form.disable();
    });

    this.form.afterChanges().subscribe(({ changes, form }) => {
      console.log(changes);
    });
  }

  handleSubmit(data) {
    /* ... */
  }
}
```
